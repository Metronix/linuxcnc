/* Autogenerated by /usr/bin/halcompile on Wed Jan 29 16:21:55 2025 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:i2c_rasp:i2c_fd rasp voltage thc");
MODULE_INFO(linuxcnc, "descr:\n\nLeitura de tensao Labsolda\n\n.I VERSION:\n.br\n001\n\n.I SUMMARY:\n.br\nUsage of this component is demonstrated in the I2c_rasp\n\n.I DISCLAIMER:\n.br\nTHE AUTHOR OF THIS SOFTWARE ACCEPTS ABSOLUTELY NO LIABILITY FOR ANY HARM OR LOSS RESULTING FROM ITS USE.\n\nIT IS EXTREMELY UNWISE TO RELY ON SOFTWARE ALONE FOR SAFETY.\n\nAny machinery capable of harming persons must have provisions for completely stopping all motors and moving parts etc. before persons enter any danger area.\n\nAll machinery must be designed to comply with local and national safety codes, and the author of this software can not, and does not, take any responsibility for such compliance.\n");
MODULE_INFO(linuxcnc, "pin:thc_enable:bit:0:in:enable/disable thc and set the IHS skip type:None:None");
MODULE_INFO(linuxcnc, "pin:arc_voltage_in:float:0:in:arc voltage input:None:None");
MODULE_INFO(linuxcnc, "pin:max_volts:float:0:in:max voltage avc(volts):None:None");
MODULE_INFO(linuxcnc, "pin:dead_zone:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:state_handler:u32:0:in:set state:None:None");
MODULE_INFO(linuxcnc, "pin:shutdown:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:voltage_out:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:voltage:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:dead_zone_out:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:max_voltage_out:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:error_handler:u32:0:out::None:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_INFO(linuxcnc, "author:Pedro Felipe Bender");
MODULE_INFO(linuxcnc, "license:GPLv2 or greater");
MODULE_LICENSE("GPLv2 or greater");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *thc_enable;
    hal_float_t *arc_voltage_in;
    hal_float_t *max_volts;
    hal_float_t *dead_zone;
    hal_u32_t *state_handler;
    hal_bit_t *shutdown;
    hal_float_t *voltage_out;
    hal_float_t *voltage;
    hal_float_t *dead_zone_out;
    hal_float_t *max_voltage_out;
    hal_u32_t *error_handler;
    int16_t value;

    int flag_conection;

    int state_handler_old;

};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_bit_newf(HAL_IN, &(inst->thc_enable), comp_id,
        "%s.thc-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->arc_voltage_in), comp_id,
        "%s.arc-voltage-in", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->max_volts), comp_id,
        "%s.max-volts", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->dead_zone), comp_id,
        "%s.dead-zone", prefix);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_IN, &(inst->state_handler), comp_id,
        "%s.state-handler", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->shutdown), comp_id,
        "%s.shutdown", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->voltage_out), comp_id,
        "%s.voltage-out", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->voltage), comp_id,
        "%s.voltage", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->dead_zone_out), comp_id,
        "%s.dead-zone-out", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->max_voltage_out), comp_id,
        "%s.max-voltage-out", prefix);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_OUT, &(inst->error_handler), comp_id,
        "%s.error-handler", prefix);
    if(r != 0) return r;
    inst->flag_conection = 0.0;
    inst->state_handler_old = 0.0;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("i2c_rasp");
    if(comp_id < 0) return comp_id;
    r = export("i2c-rasp", 0);
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef thc_enable
#define thc_enable (0+*__comp_inst->thc_enable)
#undef arc_voltage_in
#define arc_voltage_in (0+*__comp_inst->arc_voltage_in)
#undef max_volts
#define max_volts (0+*__comp_inst->max_volts)
#undef dead_zone
#define dead_zone (0+*__comp_inst->dead_zone)
#undef state_handler
#define state_handler (0+*__comp_inst->state_handler)
#undef shutdown
#define shutdown (0+*__comp_inst->shutdown)
#undef voltage_out
#define voltage_out (*__comp_inst->voltage_out)
#undef voltage
#define voltage (*__comp_inst->voltage)
#undef dead_zone_out
#define dead_zone_out (*__comp_inst->dead_zone_out)
#undef max_voltage_out
#define max_voltage_out (*__comp_inst->max_voltage_out)
#undef error_handler
#define error_handler (*__comp_inst->error_handler)
#undef value
#define value (__comp_inst->value)
#undef flag_conection
#define flag_conection (__comp_inst->flag_conection)
#undef state_handler_old
#define state_handler_old (__comp_inst->state_handler_old)


#line 58 "i2c_rasp.comp"

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>


int device_addr = 0x55; // Endereço do dispositivo
int i2c_fd;
unsigned char buf[2];
unsigned char data[4];
const char *device = "/dev/i2c-1"; // Barramento I2C

enum states{
    IDLE = 0,
    THC_OFF,
    THC_ON,
    LER_CONFIG,
    GRAVAR,
    TENSAO  
};

enum states Estados= IDLE;

int connection(){
    // Abrir o barramento I2C
    if ((i2c_fd = open(device, O_RDWR)) < 0) {
        perror("Failed to open the I2C bus");
        return 1;
    }
    // Configurar o endereço do dispositivo
    if (ioctl(i2c_fd, I2C_SLAVE, device_addr) < 0) {
        perror("Failed to acquire bus access and/or talk to slave");
        close(i2c_fd);
        return 1;
    }
    return 0;
}
FUNCTION(_) {
    
    if (flag_conection == 0) {
        error_handler = connection();
        flag_conection = (error_handler == 0) ? 1 : 0; 
    }
    if(state_handler_old != state_handler){
        switch (state_handler){
            case 1:
                Estados = THC_OFF;
                break;
            case 3:
                Estados = LER_CONFIG;
                break;
            case 4:
                Estados = GRAVAR;
                break;
            case 5:
                Estados = TENSAO;
                break;
            default: 
                break;
        }
        state_handler_old = state_handler;
    }
    switch (Estados){
        case IDLE:
            
            if(thc_enable){
                Estados = THC_ON;
            }
            break;
        case THC_OFF:
            data[0] = 1;
            if(write(i2c_fd, data, 1) != 1){
                perror("Failed to write to the I2C device");
            }
            Estados = IDLE;
            break;
        case THC_ON:
            data[0] = 2;
            if(write(i2c_fd, data, 1) != 1){
                perror("Failed to write to the I2C device");
            }
            Estados = TENSAO;
            break;
        case LER_CONFIG:
            data[0] = 3;
            if(write(i2c_fd, data, 1) != 1){
                perror("Failed to write to the I2C device");
            }
            if (read(i2c_fd, data, 4) != 4) {
                perror("Failed to read from the I2C device");
                close(i2c_fd);
                flag_conection = 0;
                Estados = THC_OFF;
            }else{
                value = (data[0] << 8) | data[1]; // MSB no último byte
                voltage_out = value / 100.0;
                dead_zone_out = data[2]/10.0;
                max_voltage_out = data[3];
                //printf("Voltage: %.2f V\n", voltage);
                //printf("Zona Morta: %.2f V\n",  data[2]/10.0);
                //printf("Max Voltage: %.2f V\n", data[3]/1.0);
                Estados = TENSAO;
            }
            break;
        case GRAVAR: 
            int16_t voltage_int = (int16_t)(arc_voltage_in * 100.0);
            data[0] =  (uint8_t)((voltage_int >> 8) & 0xFF); // MSB (byte mais significativo)
            data[1] =  (uint8_t)(voltage_int) & 0xFF;        // LSB (byte menos significativo)
            data[2] = (uint8_t)(dead_zone * 10.0);
            data[3] = (uint8_t)(max_volts);
            if(write(i2c_fd, data, sizeof(data)) != sizeof(data)){
                perror("Failed to write to the I2C device");
                flag_conection = 0;
                Estados = THC_OFF;
            }else{
                Estados = TENSAO;
            }
            break;
        case TENSAO:
            if (read(i2c_fd, buf, 2) != 2) {
                perror("Failed to read from the I2C device");
                close(i2c_fd);
                flag_conection = 0;
                Estados = THC_OFF;
                break;
            }
             value = (buf[0] << 8) | buf[1]; // MSB no último byte
             voltage = value / 100.0;
            if(!thc_enable){
                Estados = THC_OFF;
            }
            
            usleep(50000);
            break;
    }
      
    
    // Fechar o barramento
    if (shutdown) {
        close(i2c_fd);
        flag_conection = 0; // Reset para reconexão
    }
}

static int __comp_get_data_size(void) { return 0; }
